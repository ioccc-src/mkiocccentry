.\" section 3 man page for dyn_array
.\"
.\" This man page was first written by Cody Boone Ferguson for the IOCCC
.\" in 2022.
.\"
.\" Humour impairment is not virtue nor is it a vice, it's just plain
.\" wrong: almost as wrong as JSON spec mis-features and C++ obfuscation! :-)
.\"
.\" "Share and Enjoy!"
.\"     --  Sirius Cybernetics Corporation Complaints Division, JSON spec department. :-)
.\"
.TH dyn_array 3  "08 September 2025" "dyn_array"
.SH NAME
.BR dyn_array_value() \|,
.BR dyn_array_addr() \|,
.BR dyn_array_tell() \|,
.BR dyn_array_beyond() \|,
.BR dyn_array_alloced() \|,
.BR dyn_array_avail() \|,
.BR dyn_array_rewind() \|,
.BR dyn_array_create() \|,
.BR dyn_array_free() \|,
.BR dyn_array_append_value() \|,
.BR dyn_array_append_set() \|,
.BR dyn_array_concat_array() \|,
.BR dyn_array_seek() \|,
.BR dyn_array_clear() \|,
.BR dyn_array_qsort()
.\" NON_STANDARD_SORT .BR dyn_array_qsort_r() \|,
.\" NON_STANDARD_SORT .BR dyn_array_heapsort() \|,
.\" NON_STANDARD_SORT .BR dyn_array_mergesort()
\- dynamic array facility
.SH SYNOPSIS
\fB#include "dyn_array.h"\fP
.sp
\fB#define DYN_ARRAY_VERSION "..." /* format: major.minor YYYY-MM-DD */\fP
.br
.B "extern const char *const dyn_array_version;	/* library version format: major.minor YYYY-MM-DD */"
.sp
.B "#define dyn_array_value(array, type, index) (((type *)(((struct dyn_array *)(array))->data))[(index)])"
.br
.B "#define dyn_array_addr(array, type, index) (((type *)(((struct dyn_array *)(array))->data))+(index))"
.br
.B "#define dyn_array_tell(array) (((struct dyn_array *)(array))->count)"
.br
.B "#define dyn_array_beyond(array, type) (dyn_array_addr(array, type, dyn_array_tell(array)))"
.br
.B "#define dyn_array_alloced(array) (((struct dyn_array *)(array))->allocated)"
.br
.B "#define dyn_array_avail(array) (dyn_array_alloced(array) - dyn_array_tell(array))"
.br
.B "#define dyn_array_rewind(array) (dyn_array_seek((struct dyn_array *)(array), 0, SEEK_SET))"
.sp
.B "extern struct dyn_array *dyn_array_create(size_t elm_size, intmax_t chunk, intmax_t start_elm_count, bool zeroize);"
.br
.B "extern void dyn_array_free(struct dyn_array *array);"
.br
.B "extern bool dyn_array_append_value(struct dyn_array *array, void *value_to_add);"
.br
.B "extern bool dyn_array_append_set(struct dyn_array *array, void *array_to_add_p, intmax_t count_of_elements_to_add);"
.br
.B "extern bool dyn_array_concat_array(struct dyn_array *array, struct dyn_array *other);"
.br
.B "extern bool dyn_array_seek(struct dyn_array *array, off_t offset, int whence);"
.br
.B "extern void dyn_array_clear(struct dyn_array *array);"
.sp
.B "extern void dyn_array_qsort(struct dyn_array *array, int (*compar)(const void *, const void *));"
.\" NON_STANDARD_SORT .br
.\" NON_STANDARD_SORT .B "extern void dyn_array_qsort_r(struct dyn_array *array, void *thunk, int (*compar)(void *, const void *, const void *));"
.\" NON_STANDARD_SORT .br
.\" NON_STANDARD_SORT .B "extern int dyn_array_heapsort(struct dyn_array *array, int (*compar)(const void *, const void *));"
.\" NON_STANDARD_SORT .br
.\" NON_STANDARD_SORT .B "extern int dyn_array_mergesort(struct dyn_array *array, int (*compar)(const void *, const void *));"
.SH DESCRIPTION
These macros and functions provide a way to create, modify and manipulate general purpose dynamic arrays.
.sp
The function
.B dyn_array_create()
creates a dynamic array where each element is of size
.IR elm_size .
The
.I chunk
and
.I start_elm_count
specify a fixed number of elements to expand by when allocating and the starting number of elements to allocate, respectively.
If
.I zeroize
is true the newly allocated chunks are zeroed.
The function always allocates one more chunk than requested to serve as a guard chunk.
This extra chunk will not be listed in the total element allocation count.
The function returns a pointer to the new dynamic array, a
.B struct dyn_array
(see below for details).
.sp
The function
.B dyn_array_append_value()
appends the single value
.I value_to_add
to the array
.IR array .
The array will grow if all allocated values are used.
The function will return true if the address of the array of elements moved during
.BR realloc (3).
Otherwise it returns false.
.sp
The function
.B dyn_array_append_set()
appends a set of values of a given array to the end of the dynamic array.
The
.I array
is a pointer to the dynamic array.
The
.I array_to_add_p
is a pointer to the array to add to the end of the dynamic array
.IR array .
The
.I count_of_elements_to_add
is the number of elements to add to the dynamic array.
If after adding the values of the array, all allocated values are used, the array will grow.
If the address of the array of elements moved during
.BR realloc (3)
the function returns true.
Otherwise it returns false.
.sp
The function
.B dyn_array_concat_array()
concatenates the dynamic array
.I other
to the
dynamic array
.IR array .
If the address of the array of elements moved during
.BR realloc (3)
the function returns true.
Otherwise it returns false.
The contents of the other array is not modified nor is it freed.
If after adding the values of the array, all allocated values are used, the dynamic array will grow.
.sp
The function
.B dyn_array_seek()
sets the elements in use in the dynamic array
.IR array .
The
.I offset
is the offset in elements from the
.I whence
which can be:
.RS
.TP
.B SEEK_SET
offset from the dynamic array beginning.
.TQ
.B SEEK_CUR
offset from the current element in use.
.TQ
.B SEEK_END
offset from the end of the allocated elements.
.RE
.sp 1
The function will return true if the address of the array of elements moved during
.BR realloc (3)
and false otherwise.
Attempting to seek to or before the beginning of the array will have the effect of calling
.B dyn_array_clear()
as described below.
.PP
The function
.B dyn_array_clear()
will clear any element in use in the dynamic array
.I array
(if the
.I zeroize
boolean is true) and then set the number of elements in use to 0.
The function does not free allocated storage.
For that see
.BR dyn_array_free() .
.PP
The function
.B dyn_array_free()
frees the contents of the dynamic array
.BR array .
If
.I array->zeroize
is true and the data of the array is not NULL and the array has allocated nodes and the size of arrays is > 0 the function will clear the array data (via
.BR memset (3))
first.
The function does not free the
.B struct dyn_array
itself: it only frees any allocated storage.
.SS Convenience macros
.PP
The following macros are available to help you with the dynamic arrays:
.TP
.B dyn_array_value()
obtains the element (the value) of the dynamic array
.I array
of type
.I type
at index
.I index
.TP
.B dyn_array_addr()
obtains the address of the dynamic array
.I array
of an element of type
.I type
at index
.IR index .
.TP
.B dyn_array_tell()
returns the current element count of the dynamic array
.IR array .
.TP
.B dyn_array_beyond()
returns the address of the element just beyond the elements in use in the dynamic array
.IR array .
.TP
.B dyn_array_alloced()
returns the number of elements allocated in memory for the dynamic array
.IR array .
.TP
.B dyn_array_avail()
returns the number of elements available (allocated but not in use) of the dynamic array
.IR array .
.TP
.B dyn_array_rewind()
rewinds the dynamic array
.I array
back to zero elements.
.SS The struct dyn_array
.PP
The
.I dyn_array
structure is defined in
.I dyn_array.h
as follows:
.sp
.in +4n
.nf
struct dyn_array
{
    size_t elm_size;            /* Number of bytes for a single element */
    bool zeroize;               /* true ==> always zero newly allocated chunks, false ==> don't */
    intmax_t count;             /* Number of elements in use */
    intmax_t allocated;         /* Number of elements allocated (>= count) */
    intmax_t chunk;             /* Number of elements to expand by when allocating */
    void *data;                 /* allocated dynamic array of identical things or NULL */
};
.fi
.in
.SS Version string
The string
.BR dyn_array_version ,
which points to
.BR DYN_ARRAY_VERSION ,
is the current version of the
.B dyn_array
facility.
.SH SORTING DESCRIPTION
The function
.B dyn_array_qsort()
functions sort the dynamic array
according to the
.BR qsort (3)
standard C function.
.\" NON_STANDARD_SORT .PP
.\" NON_STANDARD_SORT The function
.\" NON_STANDARD_SORT .B dyn_array_qsort_r()
.\" NON_STANDARD_SORT functions sort the dynamic array
.\" NON_STANDARD_SORT according to the
.\" NON_STANDARD_SORT .BR qsort_r (3)
.\" NON_STANDARD_SORT standard C function.
.\" NON_STANDARD_SORT .PP
.\" NON_STANDARD_SORT The
.\" NON_STANDARD_SORT .B dyn_array_qsort_r()
.\" NON_STANDARD_SORT sorts identically to
.\" NON_STANDARD_SORT .B dyn_array_qsort()
.\" NON_STANDARD_SORT except that it takes an additional argument,
.\" NON_STANDARD_SORT .IR thunk ,
.\" NON_STANDARD_SORT which is passed unchanged as the first argument to function pointed to
.\" NON_STANDARD_SORT .IR compar ,
.\" NON_STANDARD_SORT thus the
.\" NON_STANDARD_SORT .B compar
.\" NON_STANDARD_SORT takes 3 arguments
.\" NON_STANDARD_SORT .RI ( thunk
.\" NON_STANDARD_SORT and pointers to 2 elements).
.\" NON_STANDARD_SORT This allows the comparison function to access additional data without using global variables, and thus
.\" NON_STANDARD_SORT .B dyn_array_qsort_r()
.\" NON_STANDARD_SORT is suitable for use in functions which must be reentrant.
.PP
The function
.B dyn_array_qsort()
.\" NON_STANDARD_SORT and the function
.\" NON_STANDARD_SORT .B dyn_array_qsort_r()
will perform modified partition-exchange sort, or quicksort,
and are an implementation of C.A.R.,
Hoare's "quicksort" algorithm, a
variant of partition-exchange sorting.
This takes O(N lg N) average time and uses median selection to avoid its O(N*N) worst-case behavior.
.PP
Although the function
.B dyn_array_qsort()
.\" NON_STANDARD_SORT and the function
.\" NON_STANDARD_SORT .B dyn_array_qsort_r()
do not explicitly allocate memory, its use of recursion does consume space on the stack.
.PP
.\" NON_STANDARD_SORT The function
.\" NON_STANDARD_SORT .B dyn_array_heapsort()
.\" NON_STANDARD_SORT functions sort the dynamic array
.\" NON_STANDARD_SORT according to the
.\" NON_STANDARD_SORT .BR heapsort (3)
.\" NON_STANDARD_SORT standard C function.
.\" NON_STANDARD_SORT .PP
.\" NON_STANDARD_SORT The
.\" NON_STANDARD_SORT .B dyn_array_heapsort()
.\" NON_STANDARD_SORT function is an implementation of J.W.J. William's "heapsort" lgorithm, a variant of selection sorting.
.\" NON_STANDARD_SORT The
.\" NON_STANDARD_SORT .B only
.\" NON_STANDARD_SORT advantage
.\" NON_STANDARD_SORT .B dyn_array_heapsort()
.\" NON_STANDARD_SORT has over
.\" NON_STANDARD_SORT over
.\" NON_STANDARD_SORT .B dyn_array_qsort()
.\" NON_STANDARD_SORT and
.\" NON_STANDARD_SORT .B dyn_array_qsort_r()
.\" NON_STANDARD_SORT is that it uses almost no additional memory.
.\" NON_STANDARD_SORT This takes O(N lg N) as a worst-case behavior.
.\" NON_STANDARD_SORT .PP
.\" NON_STANDARD_SORT The function
.\" NON_STANDARD_SORT .B dyn_array_mergesort()
.\" NON_STANDARD_SORT functions sort the dynamic array
.\" NON_STANDARD_SORT according to the
.\" NON_STANDARD_SORT .BR mergesort (3)
.\" NON_STANDARD_SORT standard C function.
.\" NON_STANDARD_SORT .PP
.\" NON_STANDARD_SORT The function
.\" NON_STANDARD_SORT .B dyn_array_mergesort()
.\" NON_STANDARD_SORT requires additional memory on the order of the size of the dynamic array that is currently in use.
.\" NON_STANDARD_SORT This function should be used only when space is not at a premium.
.\" NON_STANDARD_SORT .PP
.\" NON_STANDARD_SORT The function
.\" NON_STANDARD_SORT .B dyn_array_mergesort()
.\" NON_STANDARD_SORT is optimized for data with pre-existing order (mostly sorted).
.\" NON_STANDARD_SORT This takes O(N lg N) as a worst-case behavior,
.\" NON_STANDARD_SORT and has a best case of O(N).
.\" NON_STANDARD_SORT .PP
.\" NON_STANDARD_SORT In general case:
.\" NON_STANDARD_SORT .B dyn_array_qsort()
.\" NON_STANDARD_SORT and
.\" NON_STANDARD_SORT .B dyn_array_qsort_r()
.\" NON_STANDARD_SORT are faster than
.\" NON_STANDARD_SORT .B dyn_array_mergesort()
.\" NON_STANDARD_SORT which is faster than
.\" NON_STANDARD_SORT .BR dyn_array_heapsort() .
.\" NON_STANDARD_SORT However, the need for additional memory,
.\" NON_STANDARD_SORT and the possibility of pre-existing order (mostly sorted) data
.\" NON_STANDARD_SORT may change that relative speed order.
.PP
The sort algorithms implemented by the function
.BR dyn_array_qsort()
.\" NON_STANDARD_SORT and the function
.\" NON_STANDARD_SORT .BR dyn_array_qsort_r() ,
.\" NON_STANDARD_SORT and the function
.\" NON_STANDARD_SORT .B dyn_array_heapsort()
are
.B NOT
stable.
If two dynamic array elements compare as equal, their order in the sorted array is undefined.
Sorting the dynamic array again may change the relative order of equal dynamic array elements.
That is, equal dynamic array elements may change their relative order during the sort, and there is
.I NO
ability to control the relative order of equal dynamic array elements.
.\" NON_STANDARD_SORT .PP
.\" NON_STANDARD_SORT The
.\" NON_STANDARD_SORT .B dyn_array_mergesort()
.\" NON_STANDARD_SORT is stable.
.\" NON_STANDARD_SORT That is, equal dynamic array elements will not change change their relative order during the sort.
.SH RETURN VALUE
.PP
The function
.B dyn_array_create()
returns a pointer to a
.B struct dyn_array
which is the address of the newly allocated struct.
It does not return on error.
.PP
The functions
.BR dyn_array_append_value() \|,
.BR dyn_array_append_set() \|,
.BR dyn_array_concat_array() \|,
and
.B dyn_array_seek()
return true if the address of the array of elements moved during
.BR realloc (3).
Otherwise they return false.
.PP
The function
.BR dyn_array_clear() \|,
.BR dyn_array_qsort() \|,
.\" NON_STANDARD_SORT .BR dyn_array_qsort_r() \|,
and
.B dyn_array_free()
return void.
.\" NON_STANDARD_SORT .PP
.\" NON_STANDARD_SORT The functions
.\" NON_STANDARD_SORT .BR dyn_array_heapsort() \|,
.\" NON_STANDARD_SORT and
.\" NON_STANDARD_SORT .B dyn_array_mergesort()
.\" NON_STANDARD_SORT return the valueÂ 0 if successful,
.\" NON_STANDARD_SORT and set the global variable
.\" NON_STANDARD_SORT .B errno
.\" NON_STANDARD_SORT to
.\" NON_STANDARD_SORT .BR 0 .
.\" NON_STANDARD_SORT They return
.\" NON_STANDARD_SORT .B \-1
.\" NON_STANDARD_SORT if a sorting error is encountered, and the underlying standard C function changes the global variable
.\" NON_STANDARD_SORT to indicate the error.
.SH EXAMPLE
For an example program that uses the dynamic array facility see the files
.I dyn_test.h
and
.IR dyn_test.c .
.SH SEE ALSO
.\" NON_STANDARD_SORT .BR heapsort (3),
.BR memset (3),
.\" NON_STANDARD_SORT .BR mergesort (3),
.BR qsort (3),
.\" NON_STANDARD_SORT .BR qsort_r (3),
and
.BR realloc (3).
.SH HISTORY
The dyn_array facility was first written by Landon Curt Noll in 2014 for use in tools such as STS (see the https://github.com/arcetri/STS GitHub repo).
