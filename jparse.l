/* vim: set tabstop=8 softtabstop=4 shiftwidth=4 noexpandtab : */

/* JSON parser - flex grammar
 *
 * XXX This is VERY incomplete but the .info.json and .author.json files
 * generated by mkiocccentry do not cause any errors. No parse tree is generated
 * by the parser yet so no verification is done yet.
 *
 * In addition to the parser not doing anything there's possibly missing grammar and
 * there might be some grammar that's not correct (though we think we have that
 * okay).
 *
 * XXX Once the parser is done test older versions of both flex and bison to see
 * if they can generate the proper code.
 *
 * This is a work in progress but as of the past few days (it's 16 May 2022 as I
 * write this) much progress has been made!
 */

/* Section 1: Declarations and option settings */
/*
 * noyywrap prevents needing to link in the flex(1) library which means those
 * without flex can compile the code. Even if everyone had flex(1) though under
 * macOS you have to pass -ll to the compiler to link in the flex library
 * whereas in other systems you have to use -lfl which would cause a lot of
 * problems. Another way is to provide 'int yywrap() { return 1; }' but this is
 * unnecessary.
 */
%option noyywrap yylineno nodefault 8bit

/*
 * An IOCCC satirical take on flex and bison
 *
 * As we utterly object to the hideous code that flex and bison generate we
 * point it out in an ironic way by changing the prefix yy to ugly_ so that
 * flex actually calls itself ugly. This is satire for the IOCCC (although we
 * still believe that flex generates ugly code)!
 *
 * This means that for some symbols later in the file we use ugly_ instead of
 * yy. For example it's ugly_lval instead of yylval and best of all ugly_parse()
 * for it _is_ an ugly parser. Another one is ugly_error() instead of yyerror().
 *
 * A negative consequence here is that because of the prefix being set to
 * ugly_ there's a typedef in the parser that _might_ suggest _our_ struct json
 * is ugly:
 *
 *	typedef struct json UGLY_STYPE;
 *
 * At first glance this is a valid concern. However we argue that even if this
 * is so the struct might well have to be ugly because it's for a json parser; a
 * json parser necessarily has to be ugly due to the spec: one could easily be
 * forgiven for wondering if the authors of the json specification were on drugs
 * at the time of writing them!
 *
 * Please note that we're _ABSOLUTELY NOT_ saying that they were and we use the
 * term very loosely as well: we do not want to and we are not accusing anyone
 * of being on drugs (we rather find addiction a real tragedy and anyone with an
 * addiction should be treated well and given the help they need) but the fact
 * is that the JSON specification is barmy and those who are in favour of it
 * must surely be in the JSON Barmy Army (otherwise known as the Barmy Army
 * Jointly Staying On Narcotics :-)).
 *
 * Thus as much as we find the specification objectionable we rather feel sorry
 * for those poor lost souls who are indeed in the JSON Barmy Army and we
 * apologise to them in a light and fun way and with hope that they're not
 * terribly humour impaired. :-)
 *
 * BTW: If you want to see all the symbols (re?)defined to something ugly run:
 *
 *	grep -i '#[[:space:]]*define[[:space:]].*ugly_' *.c
 *
 * after generating the files; and if you want to see only what was changed from
 * yy or YY to refer to ugly_ or UGLY_:
 *
 *	grep -i '#[[:space:]]*define[[:space:]]*yy.*ugly_' *.c
 *
 * This will help you find the right symbols should you need them. If (as is
 * likely to happen) the parser is split into another repo for a json parser by
 * itself I will possibly remove this prefix: this is as satire for the IOCCC
 * (though we all believe that the generated code is in fact ugly).
 *
 * WARNING: Although we use the prefix ugly_ the scanner and parser will at
 * times refer to yy and YY and other times refer to ugly_ and UGLY_ (partly
 * because WE refer to ugly_ and UGLY_). So if you're trying to sift through
 * that ugly spaghetti code (which we strongly recommend you do not do as it will
 * likely cause nightmares and massive brain pain) you'll want to check yy/YY as
 * well as ugly_/UGLY_. But really you oughtn't try and go through that code so
 * you need only pay attention to the ugly_ and UGLY_ prefixes (in the *.l and
 * *.y files) which again are satire for the IOCCC. See also the apology in the
 * generated files or directly looking at sorry.tm.ca.h.

 */
%option prefix="ugly_"

%{
/* Declarations etc. go here.
 *
 * Code is copied verbatim near the top of the generated code.
 */

/* our header file - #includes what we need */
#include "jparse.h"

int ugly_length = 0;

/*
 * An exception where the prefix does not change YY to UGLY_ is YY_BUFFER_STATE
 * but because it IS ugly we have done it for them in jparse.h so that where one
 * sees UGLY__BUFFER_STATE it's actually YY_BUFFER_STATE.
 */
UGLY__BUFFER_STATE bs;
%}

/*
 * Section 2: Patterns (regular expressions) and actions.
 */

/*
 * XXX JSON_WS is not needed but for testing I have the whitespace here
 * and below in the actions I print out that it is whitespace and how many are
 * being ignored. The text looks like one of:
 *
 *	ignoring 1 whitespace
 *	ignoring [2-9]+ whitespaces
 *
 * to help distinguish it from other patterns matched.
 */
JSON_WS			[ \t\r\n]+

/*
 * NOTE: On the subject of JSON_STRING one might ask the question about the
 * tighter restrictions on JSON strings and why we don't even consider them.
 * This is a good question but the answer is simple: the JSON string conversion
 * routines actually do these checks. This simplifies the parser regex and so we
 * don't have to worry about complicating the parser unnecessarily.
 */
JSON_STRING		\"([^\n"]|\\\")*\"
JSON_INTEGER		-?([1-9][0-9]*|0)
JSON_FRACTION		"."[0-9]+
JSON_EXPONENT		[Ee][-+]?[0-9]+
JSON_NUMBER		({JSON_INTEGER}|{JSON_INTEGER}{JSON_FRACTION}|{JSON_INTEGER}{JSON_FRACTION}{JSON_EXPONENT})
JSON_TRUE		"true"
JSON_FALSE		"false"
JSON_NULL		"null"
JSON_OPEN_BRACE		"{"
JSON_CLOSE_BRACE	"}"
JSON_OPEN_BRACKET	"["
JSON_CLOSE_BRACKET	"]"
JSON_COLON		":"
JSON_COMMA		","

/* Actions. */
%%
{JSON_WS}		{
			    /*
			     * Whitespace
			     *
			     * Not needed but included for now for debugging
			     * purposes.
			     */
			    fprintf(stderr, "\nignoring %ju whitespace%s\n", (uintmax_t)ugly_leng, yyleng==1?"":"s");
			}

{JSON_STRING}		{
			    /* string */
			    ugly_length = ugly_leng;
			    return JSON_STRING;
			}

{JSON_NUMBER}		{
			    /* number */
			    return JSON_NUMBER;
			}

{JSON_NULL}		{
			    /* null object */
			    return JSON_NULL;
			}

{JSON_TRUE}		{
			    /* boolean: true */
			    return JSON_TRUE;
			}
{JSON_FALSE}		{
			    /* boolean: false */
			    return JSON_FALSE;
			}

{JSON_OPEN_BRACE}	{
			    /* start of object */
			    return JSON_OPEN_BRACE;
			}
{JSON_CLOSE_BRACE}	{
			    /* end of object */
			    return JSON_CLOSE_BRACE;
			}

{JSON_OPEN_BRACKET}	{
			    /* start of array */
			    return JSON_OPEN_BRACKET;
			}
{JSON_CLOSE_BRACKET}	{
			    /* end of array */
			    return JSON_CLOSE_BRACKET;
			}

{JSON_COLON}		{
			    /* colon or 'equals' */
			    return JSON_COLON;
			}

{JSON_COMMA}		{
			    /* comma: name/value pair separator */
			    return JSON_COMMA;
			}

.			{
			    /* invalid token: any other character */
			    ugly_error(NULL, "\ninvalid token: 0x%02x = <%c>\n", *ugly_text, *ugly_text);
			    return JSON_INVALID_TOKEN;
			}

%%

/* Section 3: Code that's copied to the generated scanner */

/*
 * parse_json - parse a JSON document of a given length
 *
 * Given a pointer to char and a length, use the parser to determine if the json
 * is valid or not.
 *
 * given:
 *
 *	ptr	    - pointer to start of json blob
 *	len	    - length of the json blob
 *	is_valid    - != NULL ==> set to true or false depending on json validity
 *	dbg_stream  - != NULL ==> write debugging info to the open steam dbg_stream
 *
 * return:
 *	pointer to a JSON parse tree
 *
 * NOTE: Until the JSON parser is finished this only parses the string (and not
 * necessarily correctly); it does NOT build a parse tree!
 *
 * NOTE: The reason this is in the scanner and not the parser is because
 * UGLY__BUFFER_STATE is part of the scanner and not the parser. There might be
 * a better way to go about this but I'll know about this more later on. Like
 * everything else here this is subject to change!
 *
 * NOTE: This function only warns on error. The reason for this is because more
 * than one string and/or file can then be verified during testing. Once the
 * parser is complete it will use jerr(). Note that this refers to errors
 * unspecific to the parser.
 */
struct json *
parse_json(char const *ptr, size_t len, bool *is_valid, FILE *dbg_stream)
{
    struct json *node = NULL;		/* the JSON parse tree */
    int ret = 0;			/* ugly_parse() return value */

    /*
     * firewall
     */
    if (ptr == NULL) {

	/* this should never happen */
	warn(__func__, "ptr is NULL");
	++num_errors;

	/* if allowed, report invalid JSON */
	if (is_valid != NULL) {
	    *is_valid = false;
	}

	/* return a blank JSON tree */
	node = json_alloc(JTYPE_UNSET);
	return node;
    }
    if (len <= 0) {

	/* warn about bogus length */
	warn( __func__, "len: %ju <= 0", (uintmax_t)len);
	++num_errors;

	/* if allowed, report invalid JSON */
	if (is_valid != NULL) {
	    *is_valid = false;
	}

	/* return a blank JSON tree */
	node = json_alloc(JTYPE_UNSET);
	return node;
    }

    /*
     * scan the blob
     */
    ugly_lineno = 1;
    bs = ugly__scan_bytes(ptr, len);
    if (bs == NULL) {

	/*
	 * warn about a scan error
	 */
	warn(__func__, "unable to scan string");
	++num_errors;

	/* if allowed, report invalid JSON */
	if (is_valid != NULL) {
	    *is_valid = false;
	}

	/* return a blank JSON tree */
	node = json_alloc(JTYPE_UNSET);
	return node;
    }

    /*
     * XXX - control the output
     *
     * All of the debugging that should be under control of json_dbg()
     * and the JSON verbosity level such that -J 0 does not output anything.
     * Currently this cannot be done because the lexer and parser are set to
     * print out a lot of debug information.
     */
    json_dbg(json_verbosity_level, __func__, "*** BEGIN PARSE:\n<");
    if (dbg_stream != NULL) {
	fprint_str(dbg_stream, ptr, len);
	fprintf(dbg_stream, "\n>\n");
    }

    /*
     * parse the blob, passing into the parser the node. The parser can access
     * node directly by referring to node. For example to print out the type
     * (currently it'll only be JTYPE_UNSET as it's NULL) it could do:
     *
     *	json_dbg(JSON_DBG_LOW, __func__, "node type: %s", json_element_type_name(node));
     *
     */
    ret = ugly_parse(node);

    /*
     * scan and parse clean up
     */
    ugly__delete_buffer(bs);
    bs = NULL;

    /*
     * XXX - control the output
     *
     * All of the debugging that should be under control of json_dbg()
     * and the JSON verbosity level such that -J 0 does not output anything.
     * Currently this cannot be done because the lexer and parser are set to
     * print out a lot of debug information.
     */
    json_dbg(json_verbosity_level, __func__, "*** END PARSE");
    if (dbg_stream != NULL) {
	fprint_newline(dbg_stream, output_newline);
    }

    /*
     * report scanner / parser success or failure
     */
    if (is_valid != NULL) {
	*is_valid = ret == 0;
    }
    /* XXX - return a blank JSON tree until we can get a tree via ugly_parse somehow - XXX */
    node = json_alloc(JTYPE_UNSET);
    return node;
}


/*
 * parse_json_file	    - parses file file
 *
 * given:
 *
 *	filename    - filename to parse
 *	is_valid    - != NULL ==> set to true or false depending on json validity
 *	dbg_stream  - != NULL ==> write debugging info to the open steam dbg_stream
 *
 * return:
 *	pointer to a JSON parse tree
 *
 * If filename is NULL or the filename is not a readable file (or is empty) or
 * if read_all() returns NULL the function warns but does nothing else.
 *
 * NOTE: Until the JSON parser is finished this only parses the file (and not
 * necessarily correctly); it does NOT build a parse tree!
 *
 * NOTE: The reason this is in the scanner and not the parser is because
 * YY_BUFFER_STATE is part of the scanner and not the parser and that's required
 * for the parse_json_block() function so I think both ought to be here. There
 * might be a better way to go about that but I'll know more about this later
 * on. Like everything else here this is subject to change!
 *
 * NOTE: This function only warns on error. The reason for this is because more
 * than one string and/or file can then be verified during testing. Once the
 * parser is complete it will use jerr(). Note that this refers to errors
 * unspecific to the parser.
 *
 */
struct json *
parse_json_file(char const *filename, bool *is_valid, FILE *dbg_stream)
{
    struct json *node = NULL;		/* the JSON parse tree */
    bool is_stdin = false;	/* true if reading from stdin (filename == "-") */
    char *data = NULL;		/* used to determine if there are NUL bytes in the file */
    size_t len = 0;		/* length of data read */
    int ret;

    /*
     * firewall
     */
    if (filename == NULL) {

	/* this should actually never happen if called from jparse */
	warn(__func__, "passed NULL filename");
	++num_errors;

	/* if allowed, report invalid JSON */
	if (is_valid != NULL) {
	    *is_valid = false;
	}

	/* return a blank JSON tree */
	node = json_alloc(JTYPE_UNSET);
	return node;

    } else if (*filename == '\0') { /* strlen(filename) == 0 */

	/* warn about bogus filename */
	warn(__func__, "passed empty filename");
	++num_errors;

	/* if allowed, report invalid JSON */
	if (is_valid != NULL) {
	    *is_valid = false;
	}

	/* return a blank JSON tree */
	node = json_alloc(JTYPE_UNSET);
	return node;
    }

    /*
     * if file is -, then this as a special way to indicate stdin
     */
    is_stdin = !strcmp(filename, "-");

    /*
     * case: will read from stdin
     */
    if (is_stdin == true) {
	ugly_in = stdin;

    /*
     * case: will read from a file
     */
    } else {

	/*
	 * validate filename
	 */
	if (!is_file(filename)) {

	    /* report missing filename */
	    warn(__func__, "passed filename that's not actually a file: %s", filename);
	    ++num_errors;

	    /* if allowed, report invalid JSON */
	    if (is_valid != NULL) {
		*is_valid = false;
	    }

	    /* return a blank JSON tree */
	    node = json_alloc(JTYPE_UNSET);
	    return node;
	}
	if (!is_read(filename)) {

	    /* report unreadable file */
	    warn(__func__, "passed filename not readable file: %s", filename);
	    ++num_errors;

	    /* if allowed, report invalid JSON */
	    if (is_valid != NULL) {
		*is_valid = false;
	    }

	    /* return a blank JSON tree */
	    node = json_alloc(JTYPE_UNSET);
	    return node;
	}

	/*
	 * open file for scanner to use
	 */
	errno = 0;
	ugly_in = fopen(filename, "r");
	if (ugly_in == NULL) {

	    /* warn about file open error */
	    warnp(__func__, "couldn't open file %s, ignoring", filename);
	    ++num_errors;

	    /* if allowed, report invalid JSON */
	    if (is_valid != NULL) {
		*is_valid = false;
	    }

	    /* return a blank JSON tree */
	    node = json_alloc(JTYPE_UNSET);
	    return node;
	}
    }

    /*
     * read the entire file into memory
     */
    data = read_all(ugly_in, &len);
    if (data == NULL) {

	/* warn about read error */
	warn(__func__, "couldn't read in %s", is_stdin?"stdin":filename);
	++num_errors;
	clearerr_or_fclose(filename, ugly_in);

	/* if allowed, report invalid JSON */
	if (is_valid != NULL) {
	    *is_valid = false;
	}

	/* return a blank JSON tree */
	node = json_alloc(JTYPE_UNSET);
	return node;
    }
    if (len <= 0) {

	/* warn about empty file */
	warn(__func__, "%s is empty", is_stdin?"stdin":filename);
	++num_errors;
	clearerr_or_fclose(filename, ugly_in);

	/* if allowed, report invalid JSON */
	if (is_valid != NULL) {
	    *is_valid = false;
	}

	/* return a blank JSON tree */
	node = json_alloc(JTYPE_UNSET);
	return node;
    }

    /*
     * JSON parse the data from the file
     */
    json_dbg(json_verbosity_level, __func__, "Calling parse_json with length %ju:", (uintmax_t)len);
    node = parse_json(data, len, is_valid, stderr);

    /* free data */
    free(data);
    data = NULL;

    /*
     * we cannot use clearerr_or_fclose() here as it's possible that ugly_in
     * will be NULL and so we do it manually instead.
     */
    if (is_stdin == true)
	clearerr(stdin);
    else if (ugly_in != NULL) {
	errno = 0;
	ret = fclose(ugly_in);
	if (ret != 0) {
	    warnp(__func__, "error in fclose on file %s", filename);
	}
	ugly_in = NULL;
    }

    /*
     * XXX - control the output
     *
     * All of the debugging that should be under control of json_dbg()
     * and the JSON verbosity level such that -J 0 does not output anything.
     * Currently this cannot be done because the lexer and parser are set to
     * print out a lot of debug information.
     */
    if (dbg_stream != NULL) {
	fprint_newline(dbg_stream, output_newline);
    }

    /*
     * return the JSON parse tree node
     */
    return node;
}
