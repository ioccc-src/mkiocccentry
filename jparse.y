/* vim: set tabstop=8 softtabstop=4 shiftwidth=4 noexpandtab : */

/* JSON parser - bison grammar
 *
 * XXX This is VERY incomplete but the .info.json and .author.json files
 * generated by mkiocccentry do not cause any errors. No parse tree is generated
 * yet and so no verification is done yet either.
 *
 * There are no actions yet. I'm not sure when I will be adding the actions and
 * it's very likely that I won't add all at once.
 *
 * Before the parser can be complete there are still some other things that have
 * to be done. All of this is a work in progress!
 */

/* Section 1: Declarations */

/*
 * We enable verbose error messages during development but once the parser is
 * complete we will disable this as it's very verbose.
 *
 * NOTE: Previously we used the -D option to bison because the %define is not
 * POSIX Yacc portable but we no longer do that because we make use of another
 * feature that's not POSIX Yacc portable that we deem worth it as it produces
 * easier to read error messages.
 */
%define parse.error verbose
/*
 * We enable lookahead correction parser for improved errors
 */
%define parse.lac full


/*
 * We use our struct json (see json.h for its definition) instead of bison
 * %union.
 */
%define api.value.type {struct json}


/*
 * An IOCCC satirical take on bison and flex
 *
 * As we utterly object to the hideous code that bison and flex generate we
 * point it out in an ironic way by changing the prefix yy to ugly_ so that
 * bison actually calls itself ugly. This is satire for the IOCCC (although we
 * still believe that bison generates ugly code)!
 *
 * This means that to access the struct json's union type in the lexer we can do
 * (because the prefix is ugly_ as described above):
 *
 *	ugly_lval.type = ...
 *
 * A negative consequence here is that because of the api.prefix being set to
 * ugly_ there's a typedef that _might suggest_ that _our struct json_ is ugly:
 *
 *	typedef struct json UGLY_STYPE;
 *
 * At first glance this is a valid concern. However we argue that even if this
 * is so the struct might well have to be ugly because it's for a json parser; a
 * json parser necessarily has to be ugly due to the spec: one could easily be
 * forgiven for wondering if the authors of the json specification were on drugs
 * at the time of writing them.
 *
 * Please note that we're _ABSOLUTELY NOT_ saying that they were and we use the
 * term very loosely as well: we do not want to and we are not accusing anyone
 * of being on drugs (we rather find addiction a real tragedy and anyone with an
 * addition should be treated well and given the help they need) but the fact is
 * that the JSON specification is barmy and those who are in favour of it must
 * surely be in the JSON Barmy Army (otherwise known as the Barmy Army Jointly
 * Staying On Narcotics :-)).
 *
 * Thus as much as we find the specification objectionable we rather feel sorry
 * for those poor lost souls who are indeed in the JSON Barmy Army and we
 * apologise to them in a light and fun way and with hope that they're not
 * terribly humour impaired. :-)
 *
 * BTW: If you want to see all the symbols (re?)defined to something ugly run:
 *
 *	grep -i '#[[:space:]]*define[[:space:]].*ugly_' *.c
 *
 * after generating the files; and if you want to see only what was changed from
 * yy or YY to refer to ugly_ or UGLY_:
 *
 *	grep -i '#[[:space:]]*define[[:space:]]*yy.*ugly_' *.c
 *
 * This will help you find the right symbols should you need them. If (as is
 * likely to happen) the parser is split into another repo for a json parser by
 * itself I will possibly remove this prefix: this is as satire for the IOCCC
 * (though we all believe that the generated code is in fact ugly).
 */
%define api.prefix {ugly_}

%{
#include <inttypes.h>
#include <stdio.h>
#include <unistd.h> /* getopt */
#include "jparse.h"

bool output_newline = true;		/* true ==> -n not specified, output new line after each arg processed */
unsigned num_errors = 0;		/* > 0 number of errors encountered */


/* debug information during development */
int ugly_debug = 1;

int token_type = 0;
%}


/*
 * Terminal symbols (token kind)
 *
 * For most of the terminal symbols we use string literals to identify them as
 * this makes it easier to read error messages. This feature is not POSIX Yacc
 * compatible but we've decided that the benefit outweighs this fact.
 */
%token JSON_OPEN_BRACE "{"
%token JSON_CLOSE_BRACE "}"
%token JSON_OPEN_BRACKET "["
%token JSON_CLOSE_BRACKET "]"
%token JSON_COMMA ","
%token JSON_COLON ":"
%token JSON_NULL "null"
%token JSON_TRUE "true"
%token JSON_FALSE "false"
%token JSON_STRING
%token JSON_NUMBER
%token JSON_INVALID_TOKEN


/* Section 2: Rules
 *
 * XXX I believe all the rules are here but there are no actions yet.
 */
%%
json:		/* empty */
		| json_element
		| JSON_OPEN_BRACE JSON_CLOSE_BRACE
		| JSON_OPEN_BRACKET JSON_CLOSE_BRACKET
		;

json_value:	  json_object
		| json_array
		| JSON_STRING
		| json_number
		| JSON_TRUE
		| JSON_FALSE
		| JSON_NULL
		;

json_number:	JSON_NUMBER ;

json_object:	JSON_OPEN_BRACE json_members JSON_CLOSE_BRACE
		;

json_members:	json_member
		| json_member JSON_COMMA json_members
		;

json_member:	JSON_STRING JSON_COLON json_element
		;

json_array:	JSON_OPEN_BRACKET json_elements JSON_CLOSE_BRACKET
		;

json_elements:	json_element
		| json_element JSON_COMMA json_elements
		;

json_element:	json_value


%%
/* Section 3: C code */
int
main(int argc, char **argv)
{
    char const *program = NULL;	    /* our name */
    extern char *optarg;	    /* option argument */
    extern int optind;		    /* argv index of the next arg */
    bool strict = false;	    /* true ==> strict mode (currently unused: this is for when a JSON parser is added) */
    bool string_flag_used = false;  /* true ==> -S string was used */
    int ret;			    /* libc return code */
    int i;


    /*
     * parse args
     */
    program = argv[0];
    while ((i = getopt(argc, argv, "hv:qVnSs:")) != -1) {
	switch (i) {
	case 'h':		/* -h - print help to stderr and exit 0 */
	    usage(2, "-h help mode", program); /*ooo*/
	    not_reached();
	    break;
	case 'v':		/* -v verbosity */
	    /*
	     * parse verbosity
	     */
	    verbosity_level = parse_verbosity(program, optarg);
	    break;
	case 'q':
	    msg_warn_silent = true;
	    break;
	case 'V':		/* -V - print version and exit */
	    errno = 0;		/* pre-clear errno for warnp() */
	    ret = printf("%s\n", JPARSE_VERSION);
	    if (ret <= 0) {
		warnp(__func__, "printf error printing version string: %s", JPARSE_VERSION);
	    }
	    exit(0); /*ooo*/
	    not_reached();
	    break;
	case 'n':
	    output_newline = false;
	    break;
	case 'S':
	    /*
	     * XXX currently this is unused as json parsing is not done yet.
	     */
	    strict = true;
	    /* the if is only to prevent the warning that it's not yet used */
	    if (strict)
		dbg(DBG_MED, "enabling strict mode");
	    break;
	case 's':
	    /*
	     * So we don't trigger missing arg. Maybe there's another way but
	     * nothing is coming to my mind right now.
	     */
	    string_flag_used = true;

	    dbg(DBG_NONE, "Calling parse_json_string(\"%s\"):", optarg);
	    /* parse arg as a string */
	    parse_json_string(optarg);
	    /*
	     * XXX Rather than having an option to disable strict mode so that
	     * in the same invocation we can test some strings in strict mode
	     * and some not strict after each string is parsed the strict mode
	     * is disabled so that another -s has to be specified prior to the
	     * string. This does mean that if you want strict parsing of files
	     * and you specify the -s option then you must have -S after the
	     * string args.
	     *
	     * But the question is: should it be this way or should it be
	     * another design choice? For example should there be an option that
	     * specifically disables strict mode so that one can not worry about
	     * having to specify -s repeatedly? I think it might be better this
	     * way but I'm not sure what letter should do it. Perhaps -x? If we
	     * didn't use -S for strict it could be S but we do so that won't
	     * work.
	     */

	    /* the if is only to prevent the warning that it's not yet used */
	    if (!strict)
		dbg(DBG_MED, "disabling strict mode");
	    strict = false;
	    break;
	default:
	    usage(2, "invalid -flag", program); /*ooo*/
	    not_reached();
	}
    }

    /* perform IOCCC sanity checks */
    ioccc_sanity_chks();

    /*
     * case: process arguments on command line
     */
    if (argc - optind > 0) {

	/*
	 * process each argument in order
	 */
	for (i=optind; i < argc; ++i) {
	    dbg(DBG_NONE, "Calling parse_json_file(\"%s\"):", argv[i]);
	    parse_json_file(argv[i]);
	}

    } else if (!string_flag_used) {
	usage(2, "-s string was not used and file specified", program); /*ooo*/
	not_reached();
    }


    /*
     * All Done!!! - Jessica Noll, age 2
     */
    exit(num_errors != 0); /*ooo*/
}

void
ugly_error(char const *format, ...)
{
    va_list ap;

    va_start(ap, format);

    /*
     * We use fprintf and vfprintf instead of err() but in the future this might
     * use an error function of some kind, perhaps a variant of jerr() (a
     * variant because the parser cannot provide all the information that the
     * jerr() function expects). In the validation code we will likely use
     * jerr(). It's possible that the function jerr() will change as well but
     * this will be decided after the parser is complete.
     */
    fprintf(stderr, "JSON parser error on line %d: ", ugly_lineno);
    vfprintf(stderr, format, ap);
    fprintf(stderr, "\n");

    va_end(ap);
}

/*
 * usage - print usage to stderr
 *
 * Example:
 *      usage(3, "missing required argument(s), program: %s", program);
 *
 * given:
 *	exitcode        value to exit with
 *	str		top level usage message
 *	program		our program name
 *
 * NOTE: We warn with extra newlines to help internal fault messages stand out.
 *       Normally one should NOT include newlines in warn messages.
 *
 * This function does not return.
 */
static void
usage(int exitcode, char const *str, char const *prog)
{
    /*
     * firewall
     */
    if (str == NULL) {
	str = "((NULL str))";
	warn(__func__, "\nin usage(): program was NULL, forcing it to be: %s\n", str);
    }
    if (prog == NULL) {
	prog = "((NULL prog))";
	warn(__func__, "\nin usage(): program was NULL, forcing it to be: %s\n", prog);
    }

    /*
     * print the formatted usage stream
     */
    fprintf_usage(DO_NOT_EXIT, stderr, "%s\n", str);
    fprintf_usage(exitcode, stderr, usage_msg, prog, DBG_DEFAULT, JPARSE_VERSION);
    exit(exitcode); /*ooo*/
    not_reached();
}
