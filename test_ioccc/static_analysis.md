# Static analysis of code

In this file we document how to correctly modify the Makefile (or rather its
variables) in case (for example) you wish to enable additional warnings or make
other kinds of changes. We will document fixes to some of the warnings enabled
by `clang -Weverything` as well as make some general notes. We will also
document warnings that can be safely ignored and explain why.

Although it might seem like such a document and title would discuss lints we
don't for reasons we care not to get into. :-)

After the warnings with clang `-Weverything` we discuss clang `scan-build`.


## Making modifications to the Makefiles: an example

Rather than changing the Makefiles themselves we provide a way to override
variables in each directory's Makefile. To explain how to do this we provide
this example which we'll actually use for much of this document.

Let's say you wish to change the variables `CFLAGS` (or rather the warning flags
which are included in the `CFLAGS` as `WARN_FLAGS`) and `CC` so that you can use
`-Weverything` of `clang` you can do the following:


```sh
cat > makefile.local << "EOF"
CC= clang
WARN_FLAGS += -Weverything -Wno-error
EOF
```

You can do this in any directory with a Makefile to override the warning flags
and the compiler which we'll use for much of this document. You can copy this
file to the other subdirectories or you can make a symlink e.g. something like:


```sh
cd soup;
ln -s ../makefile.local .
```

After this the `soup/` subdirectory will also use the modifications (we do not
pass the CFLAGS to other Makefiles though maybe we should).

Note: we throw in the option `-Wno-error` to prevent the compiler from aborting
prematurely.

Given various errors that we have chosen to ignore (see below), the
following macOS makefile.local file is worth considering as you
re-test these issues:

```sh
cat > makefile.local << "EOF"
CC= clang
WARN_FLAGS += -Weverything -Wno-error -Wno-padded -Wno-poison-system-directories \
	-Wno-unreachable-code-break
EOF
```

This way we can get a list of all warnings like:

```sh
make clobber all > warnings.log 2>&1;
grep -E ' error: | warning: ' warnings.log
```


Now one can look at the `warnings.log` file and analyse it all at once without
having to scroll up and down.

In a moment we'll use this file.


### A note about ASAN

If you want to use ASAN make sure to set this environment var:

	ASAN_OPTIONS= "detect_stack_use_after_return=1"

and also modify the CFLAGS a bit as well:

	CFLAGS+= -O0 -g -pedantic ${WARN_FLAGS} -fsanitize=address -fno-omit-frame-pointer

To do this you may use the feature above with the `makefile.local`.  Note that
there might be some redundancy in your `CFLAGS` but we specify these explicitly
as some of the flags will eventually change.


### A note about the foo files and oebxergfB.h

When it comes to these three files you should ignore any warnings. In the case
of foo it would be easy to break something and in the case of oebxergfB.h only
Cody Boone Ferguson and the IOCCC Judges can update that file as it was
generated by a private tool written by Cody for this purpose (at the suggestion
of Landon) so there's nothing you could do to 'fix' any problems anyway. :-)

If you think there's a problem you can always report it of course but you need
not concern yourself trying to fix warnings here. If there are any warnings not
noted below for these files please report them but do not try fixing them.


### IMPORTANT REMINDER: test your changes

Please remember to ALWAYS run `make clobber all test` after you make a change:
just like all scientists test there ideas so too must you when making a change
to the code.


## Analysing `clang -Weverything`

Here we'll analyse the warnings (over some days) that we generated in the
section about modifying the Makefiles.

Tip: if there are a lot of warnings you might want to, when going through the
warnings log, disable the `-Weverything` and selectively enable the class of
warnings. For instance you might do instead `-Wsign-conversion` to help
identify the sign conversion warnings.



## Issue: padding struct 'struct foo' with N bytes to align
### Status: ignore
### Example:

```c
./json_parse.h:129:13: warning: padding struct 'struct json_number' with 1 byte to align 'as_int32' [-Wpadded]
    int32_t as_int32;           /* JSON integer value in int32_t form, if int32_sized == true */
```


### Solution

This warning can be safely ignored so we can add to the `WARN_FLAGS`
`-Wno-padded` to prevent us from being bothered by it further.


## Issue: macro is not used
### Status: fixed
### Examples:

```c
jparse.tab.c:230:11: warning: macro is not used [-Wunused-macros]
#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
          ^
```

### Solution

When it comes to flex and bison generated code one can ignore this warning
without any problems. If however it's somewhere else it might or might not want
to be fixed.

There are two other places where it can be ignored:


```c
jstrdecode.c:40:9: warning: macro is not used [-Wunused-macros]
#define REQUIRED_ARGS (0)       /* number of required arguments on the command line */

jstrencode.c:40:9: warning: macro is not used [-Wunused-macros]
#define REQUIRED_ARGS (0)       /* number of required arguments on the command line */
```

These can be ignored because we use this macro in all tools to be consistent. In
the case of `jstrdecode` and `jstrencode if there are no args after the options
we read from `stdin`. If however there are args we process those as strings.
Thus there is no safe way to use this macro but nevertheless we want to be
consistent.

At this time (12 January 2023) all the places that this warning is triggered can
be ignored but this does not necessarily mean that it always should be.


## Issue: warning: 'break' will never be executed
### Status: ignore
### Example

```c
jstrencode.c:181:6: warning: 'break' will never be executed [-Wunreachable-code-break]
            break;
            ^~~~~
```

### Solution

If you look at the code you will see:

```c
        case 't':               /* -t - validate the contents of the jenc[] table */
            printf("%s: Beginning jencchk test on code JSON encode/decode functions ...\n", program);
            jencchk();
            printf("%s: ... passed JSON encode/decode test\n", program);
            exit(0); /*ooo*/
            not_reached();
            break;
```


We can see indeed that the `break` will never be reached but there's a problem
with changing this: some code might be changed which could break the code if the
break statement was removed. A good example has actually happened in the past.

Choosing to ignore this very warning a long while back I (@xexyl) wrote some
code (that was obsoleted by the json parser) that had a return prior to a break.
Later on this actually happened as the return was removed and moved to the end
of the file. But if there was another case in the switch block it would have
fallen through and caused an error.


## Issue: warning: no previous prototype for function
### Status: fixed
### Examples

The first example is due to a function that is no longer used.

```c
util.c:2965:1: warning: no previous prototype for function 'find_matching_quote' [-Wmissing-prototypes]
find_matching_quote(char *q)
^
util.c:2964:1: note: declare 'static' if the function is not intended to be used outside of this translation unit
char *
^
static
```

### Solution

In this case we can safely get rid of this function.

### Another example

```c
entry_time.c:67:1: warning: no previous prototype for function 'timestr_eq_tstamp' [-Wmissing-prototypes]
timestr_eq_tstamp(char const *timestr, time_t timestamp)
^
entry_time.c:66:1: note: declare 'static' if the function is not intended to be used outside of this translation unit
bool
^
static
```

### Solution

In this case the prototype was missing so we add it to the approprate file and
recompile and, assuming no compilation errors, run `make clobber all test` to
make sure everything is okay.

### See also

This was fixed in commit cd991fae57ad4ac358c899ec2967aca8f2f2f224.


## Issue: warning: format string is not a string literal
### Status: ignore
### Example

```c
dbg.c:220:28: warning: format string is not a string literal [-Wformat-nonliteral]
    ret = vfprintf(stream, fmt, ap);
                           ^~~
```


### Solution

While normally a cause for concern, in this case the format string is passed as
a literal to the debug function (or actually `fmsg_write()` from the `msg()`
functions) where in turn the variable triggers the warning.

In our case there is no place in the code that this is triggered that is a
problem as it's all like the above example.  Moreover, calls to these debug
functions pass literal strings as the fmt argument further reducing the
potrential negative impact of this issue.


## Issue: warning: function 'foo' could be declared with attribute 'noreturn'
### Status: fixed
### Example

```c
dbg.c:3123:1: warning: function 'verr' could be declared with attribute 'noreturn' [-Wmissing-noreturn]
{
^
```

### Solution

Add the `noreturn` attribute, changing the declaration to be:


```c
extern void verr(int exitcode, char const *name, char const *fmt, va_list ap) \
           __attribute__((noreturn));
```

### See also

This was fixed in commit 5971613375469005ed252dc9bb2b63fe1ad1891d.


## Issue: warning: no previous extern declaration for non-static variable
### Status: fixed
### Examples

```c
./jparse.l:49:17: warning: no previous extern declaration for non-static variable 'bs' [-Wmissing-variable-declarations]
YY_BUFFER_STATE bs;
                ^
./jparse.l:49:1: note: declare 'static' if the variable is not intended to be used outside of this translation unit
YY_BUFFER_STATE bs;
^
```

### Solution

In this case we can make the variable static:


```c
static YY_BUFFER_STATE bs;
```

but in this case we must do a bit more to make sure this is okay. Instead of
just running `make all` we must do `make parser-o all`. This will force it to
not use the backup files which means the generated code must be regenerated. If
`make parser-o` fails (for instance because you do not have an up to date flex
version) then it will fail.

### Example

```c
./jparse.y:63:10: warning: no previous extern declaration for non-static variable 'num_errors' [-Wmissing-variable-declarations]
unsigned num_errors = 0;                /* > 0 number of errors encountered */
         ^
./jparse.y:63:1: note: declare 'static' if the variable is not intended to be used outside of this translation unit
unsigned num_errors = 0;                /* > 0 number of errors encountered */
^
```

### Solution

In this case the `num_errors` is no longer used so we can delete it. But here
too we must use `make parser-o`.


### Example

```c
./jparse.y:64:13: warning: no previous extern declaration for non-static variable 'filename' [-Wmissing-variable-declarations]
char const *filename = NULL;            /* if != NULL this is the filename we're parsing */
            ^
./jparse.y:64:1: note: declare 'static' if the variable is not intended to be used outside of this translation unit
char const *filename = NULL;            /* if != NULL this is the filename we're parsing */
^
```

### Solution

When we add `static` we discover something else: it's actually not used. Thus we
can also delete this variable and once more run `make parser-o`.

### A non-JSON example

```
In file included from txzchk.c:55:
./txzchk.h:77:6: warning: no previous extern declaration for non-static variable 'quiet' [-Wmissing-variable-declarations]
bool quiet = false;                             /* true ==> quiet mode */
     ^
./txzchk.h:77:1: note: declare 'static' if the variable is not intended to be used outside of this translation unit
bool quiet = false;                             /* true ==> quiet mode */
^
```

### Solution

We simply add `static` to the variable as it's not needed outside `txzchk`. The
same holds for `chkentry` and various others.


### A slightly more complicated example


```c
jnum_test.c:42:11: warning: no previous extern declaration for non-static variable 'test_count' [-Wmissing-variable-declarations]
int const test_count = TEST_COUNT;
          ^
jnum_test.c:42:1: note: declare 'static' if the variable is not intended to be used outside of this translation unit
int const test_count = TEST_COUNT;
^
jnum_test.c:44:7: warning: no previous extern declaration for non-static variable 'test_set' [-Wmissing-variable-declarations]
char *test_set[TEST_COUNT+1] = {
      ^
jnum_test.c:44:1: note: declare 'static' if the variable is not intended to be used outside of this translation unit
char *test_set[TEST_COUNT+1] = {
^
jnum_test.c:493:20: warning: no previous extern declaration for non-static variable 'test_result' [-Wmissing-variable-declarations]
struct json_number test_result[TEST_COUNT+1] = {
                   ^
jnum_test.c:493:1: note: declare 'static' if the variable is not intended to be used outside of this translation unit
struct json_number test_result[TEST_COUNT+1] = {
^
```

### Solution

At first glance it would appear we could just declare it static but if we do
this we will find that `jnum_chk` will fail to compile. The solution here is,
because these variables are declared in `jnum_chk.h`, `#include "jnum_chk.h"`
and run `make depend`. But this in turn will create another warning:


```c
./jnum_chk.h:95:13: warning: unused function 'chk_test' [-Wunused-function]
static bool chk_test(int testnum, struct json_number *item, struct json_number *test, size_t len, bool strict);
            ^
./jnum_chk.h:96:13: warning: unused function 'check_val' [-Wunused-function]
static void check_val(bool *testp, char const *type, int testnum, bool size_a, bool size_b, intmax_t val_a, intmax_t val_b);
            ^
./jnum_chk.h:97:13: warning: unused function 'check_uval' [-Wunused-function]
static void check_uval(bool *testp, char const *type, int testnum, bool size_a, bool size_b, uintmax_t val_a, uintmax_t val_b);
            ^
./jnum_chk.h:98:13: warning: unused function 'check_fval' [-Wunused-function]
static void check_fval(bool *testp, char const *type, int testnum, bool size_a, bool size_b,
            ^
./jnum_chk.h:100:13: warning: unused function 'usage' [-Wunused-function]
static void usage(int exitcode, char const *prog, char const *str, int expected, int argc) __attribute__((noreturn));
            ^
```

The solution is to add an include guard to the file. It would not be a good
solution to create a header file for `jnum_test` because even if this would not
be unnecessary overkill these variables are also used in `jnum_chk.c` as well.

Now running from the main directory `make clobber all` will work - under some
systems. There's one more step but since it's longer we describe it in the next
example.


### Example

```c
jnum_test.c:44:11: warning: no previous extern declaration for non-static variable 'test_count' [-Wmissing-variable-declarations]
int const test_count = TEST_COUNT;
          ^
jnum_test.c:44:1: note: declare 'static' if the variable is not intended to be used outside of this translation unit
int const test_count = TEST_COUNT;
^
jnum_test.c:46:7: warning: no previous extern declaration for non-static variable 'test_set' [-Wmissing-variable-declarations]
char *test_set[TEST_COUNT+1] = {
      ^
jnum_test.c:46:1: note: declare 'static' if the variable is not intended to be used outside of this translation unit
char *test_set[TEST_COUNT+1] = {
^
jnum_test.c:495:20: warning: no previous extern declaration for non-static variable 'test_result' [-Wmissing-variable-declarations]
struct json_number test_result[TEST_COUNT+1] = {
                   ^
jnum_test.c:495:1: note: declare 'static' if the variable is not intended to be used outside of this translation unit
struct json_number test_result[TEST_COUNT+1] = {
^

```

### Solution

Define the macro `JNUM_TEST` in `jnum_header.c` and then also add the inclusion
of `jnum_chk.h` so that the variables are declared. Then run `make
rebuild_jnum_test` from `jparse/`.

We cannot make them static exactly because they're used in `jnum_chk.c` as well.


### See also

These were fixed in commit 89f8a4b9d9b6f3533b3577398dbd559f09e27ecc and the
subsequent problem was fixed in commit 147e4b5783833e2245a3c925a3392fcbc732846d
as described next. A bug was fixed in commit
60760b84607f520f271088e214cc83b68078fe20 and a bug that resulted from this was
fixed in 3c312851717210fa1c50203b09cc36192f1621c5.

As for 60760b84607f520f271088e214cc83b68078fe20 the log was by mistake not
finished and it should probably read something like:

    A problem occurred where missing variable declarations in jnum_test.c
    was not fixed properly as after the jnum_test.c has a JNUM_TEST macro
    the jnum_header.c must #include jnum_chk.h. This is because otherwise
    the test_set, test_count and test_result were not previously declared (but
    are in jnum_chk.h). We could not have it static exactly because they're
    used in both source files.


### Example

After the above fix (see commit 89f8a4b9d9b6f3533b3577398dbd559f09e27ecc) under
some systems we run into a problem where a number of steps fail in `make prep`.
What you'll see is something like:


```sh
make prep
make_action 10 clobber OK
make_action 11 all ERROR exit code 2
make_action 12 depend OK
make_action 13 clean_mkchk_sem OK
make_action 14 all_sem_ref OK
make_action 15 mkchk_sem OK
make_action 16 all ERROR exit code 2
make_action 18 parser OK
make_action 19 all ERROR exit code 2
make_action 20 load_json_ref OK
make_action 21 use_json_ref OK
make_action 22 clean_generated_obj OK
make_action 23 all ERROR exit code 2
make_action 24 bug_report-txl ERROR exit code 2
make_action 25 shellcheck ERROR exit code 2
make_action 26 seqcexit ERROR exit code 2
make_action 27 picky ERROR exit code 2
make_action 28 tags ERROR exit code 2
make_action 29 check_man OK
make_action 30 all ERROR exit code 2
make_action 31 test ERROR exit code 2
One or more tests failed:

	make_action 11: make -f ./Makefile all: non-zero exit code: 2
	make_action 16: make -f ./Makefile all: non-zero exit code: 2
	make_action 19: make -f ./Makefile all: non-zero exit code: 2
	make_action 23: make -f ./Makefile all: non-zero exit code: 2
	make_action 24: make -f ./Makefile bug_report-txl: non-zero exit code: 2
	make_action 25: make -f ./Makefile shellcheck: non-zero exit code: 2
	make_action 26: make -f ./Makefile seqcexit: non-zero exit code: 2
	make_action 27: make -f ./Makefile picky: non-zero exit code: 2
	make_action 28: make -f ./Makefile tags: non-zero exit code: 2
	make_action 30: make -f ./Makefile all: non-zero exit code: 2
	make_action 31: make -f ./Makefile test: non-zero exit code: 2

See test_ioccc/test_ioccc.log for more details.

make prep: ERROR: prep.sh exit code: 31

make prep: see build.log for build details

make: *** [prep] Error 31
```

Now as one can see `make all` fails so running it manually we see:


```c
make all
cc -std=gnu11 -O0 -g -pedantic -Wall -Wextra -Werror  -I../.. jnum_test.c -c
In file included from jnum_test.c:37:0:
jnum_chk.h:83:13: error: 'quiet' defined but not used [-Werror=unused-variable]
 static bool quiet = false;    /* true ==> quiet mode */
             ^
```

### Solution

The problem is that because `quiet` is not used in `jnum_test.c` we have to add
an include guard for `quiet` as well. This was not picked up under macOS but it
seems to be a problem under linux. This in turn means that the rules above that
failed all depend on `make all` which as can be seen above would clearly fail!

### See also

This issue, which was created by commit
89f8a4b9d9b6f3533b3577398dbd559f09e27ecc, was fixed in commit
147e4b5783833e2245a3c925a3392fcbc732846d.


## Issue: warning: 'return' will never be executed
### Status: fixed, ignore
### Example

```c
txzchk.c:1040:2: warning: 'return' will never be executed [-Wunreachable-code-return]
        return;
        ^~~~~~
1 warning generated.
```

This was likely a typo though how I do not know. In any event it should have
been `not_reached()` which it now is.

### An example that we ignore


```c
dbg_example.c:87:12: warning: 'return' will never be executed [-Wunreachable-code-return]
    return 2; /* this return is never reached */
           ^
```

We ignore this as it serves as a demonstration to show that the exit code should
be 2.


### See also

Fixed in commit e217a44d892759a82b683f465db482df4ab790d8. Also note commit
ab5579e0473199fc676b37e37e68b032338caf5b which is the commit for the
`dbg_example.c` example above.


## Issue: warning: declaration shadows a local variable
### Status: fixed
### Example

```c
entry_util.c:551:8: warning: declaration shadows a local variable [-Wshadow]
        char *name = NULL;                      /* name string of name part of JTYPE_MEMBER */
              ^
entry_util.c:456:20: note: previous declaration is here
              char const *name, struct json_sem_val_err **val_err,
                          ^
```

### Solution

In this example we simply rename the inner variable `name` (we chose `obj_name`
because it's iterating through an object).

### Examples which we ignore

There are two variables where we ignore this warning which are:


```c
jsemtblgen.c:783:46: warning: declaration shadows a variable in the global scope [-Wshadow]
print_sem_c_src(struct dyn_array *tbl, char *tbl_name, char *cap_tbl_name)
                                             ^
jsemtblgen.c:51:14: note: previous declaration is here
static char *tbl_name = "sem_tbl";      /* -N name - name of the semantic table */
             ^
jsemtblgen.c:947:46: warning: declaration shadows a variable in the global scope [-Wshadow]
print_sem_h_src(struct dyn_array *tbl, char *tbl_name, char *cap_tbl_name)
                                             ^
jsemtblgen.c:51:14: note: previous declaration is here
static char *tbl_name = "sem_tbl";      /* -N name - name of the semantic table */
             ^
```

and

```c
txzchk.c:212:27: warning: declaration shadows a variable in the global scope [-Wshadow]
show_txz_info(char const *txzpath)
                          ^
./txzchk.h:79:20: note: previous declaration is here
static char const *txzpath = NULL;              /* the current tarball being checked */
                   ^
txzchk.c:509:28: warning: declaration shadows a variable in the global scope [-Wshadow]
check_txz_file(char const *txzpath, char const *dir_name, struct txz_file *file)
                           ^
[...]
```

### Solution

In the case of txzchk, we renamed the static global variable `txzchk`
to `txzchk_path` in order to distinguish it from a function that
is using a argument named `txzchk`.


### See also

Fixed in commit a3fb666661cf375e4b14cc6629ad519aa8593de2.


## Issue: warning: code will never be executed
### Status: ignore
### Example

```c
jparse.c:1181:13: warning: code will never be executed [-Wunreachable-code]
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                               ^~~
1 warning generated.
```

### Solution

Once again with the flex and bison generated code we must not modify the code so
we can safely ignore this.


### Example

```c
json_parse.c:392:2: warning: code will never be executed [-Wunreachable-code]
        err(100, __func__, "BITS_IN_BYTE: %d != 8", BITS_IN_BYTE);
        ^~~
json_parse.c:391:25: note: silence by adding parentheses to mark code as explicitly dead
    if (BITS_IN_BYTE != 8) {
                        ^
                        /* DISABLES CODE */ ( )
```

### Solution

We also should ignore this. This code is there to make sure that the
`BITS_IN_BYTE` is always 8 but if it's not it's an error. This is an important
check that cannot be disabled.


### Example

```c
json_sem.c:1427:6: warning: code will never be executed [-Wunreachable-code]
        if (inum->is_negative == true) {
            ^~~~
json_sem.c:1422:17: note: silence by adding parentheses to mark code as explicitly dead
    if ((time_t)-1 > 0) {
                ^
                /* DISABLES CODE */ ( )
```

### Solution

We also ignore this. The purpose of this check is to determine if `time_t` is
unsigned. In the case it is this code can be reached. This same warning for this
same reason is triggered in a number of other places and should be ignored.


### Example

```c
foo.c:279:5: warning: code will never be executed [-Wunreachable-code]
    (void) exit(42+(((four-two)>0?(four-two):(-four+two)) % (5*42))); /*ooo*/
    ^      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

### Solution

As noted earlier you should ignore this.

### See also

No commit was needed to fix this issue as it's not actually an issue. If however
you feel like you have found another case of this warning not documented please
report it. Nevertheless for a brief summary of this issue see commit
1f4a123f7cca400bd9192dd34c43bb08a0d85ca1.


## Issue: warning: cast from function call of type 'double' to non-matching type 'int'
### Status: fixed
### Example:

```c
foo.c:217:8: warning: cast from function call of type 'double' to non-matching type 'int' [-Wbad-function-cast]
                (int)fabs(0x3BF261*sin((double)((*p-0141+((42*3-42*2)-(1<<4)))%
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
foo.c:220:58: warning: cast from function call of type 'double' to non-matching type 'int' [-Wbad-function-cast]
                "NXAUTMWORWCKBLQPZDXVQJSTFHYlGIEE"[((int)fabs(043431066*sin((double)((1+*p-0x42+(
                                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

### Solution

As discussed earlier you should ignore these because of the file it's in. If you
encounter this warning in another file please report it.



## Issue: warning: 'foo' is not defined, evaluates to 0
### Status: fixed
### Example

```c
foo.c:294:5: warning: 'you_got_here' is not defined, evaluates to 0 [-Wundef]
#if you_got_here
    ^
```

### Solution

This should be ignored. It's one of many jokes in the file but since we don't
want to spoil that's all we'll say. We won't even answer if your guess is right
or wrong.

Should this be found in another file please do report it.


## Issue: warning: cast from `'const foo *'` to `'foo *'` drops const qualifier
### Status: fixed
### Example

```c
util.c:3495:19: warning: cast from 'const char *' to 'char *' drops const qualifier [-Wcast-qual]
        *first = (char *)ptr+i;
```

### Solution

In this case we do not want to modify `ptr` but we do need to modify `first` (or
what it points to) so `first` cannot be const.

### Example

```c
./jparse.l:542:41: warning: cast from 'const char *' to 'void *' drops const qualifier [-Wcast-qual]
        (void) fprint_line_buf(stderr, (void *)ptr, len, 0, 0);
                                               ^
```

### Solution

In this case we can simply remove the cast and change the function
`fprint_line_buf()` so that the `buf` variable is a pointer to a const void.
After this we must run `make clobber parser-o all`.


### Example

```c

json_sem.c:2416:81: warning: cast from 'const struct json *' to 'struct json *' drops const qualifier [-Wcast-qual]
            fpr(stream, __func__, "node type: %s ", json_item_type_name((struct json *)sem_count_err->node));
                                                                                       ^
json_sem.c:2561:81: warning: cast from 'const struct json *' to 'struct json *' drops const qualifier [-Wcast-qual]
            fpr(stream, __func__, "node type: %s ", json_item_type_name((struct json *)sem_val_err->node));
                                                                                       ^
```


### Solution

Here we change the function `json_item_type_name()` to take a pointer to a `const
struct json` and remove the cast.


### Example

```c
jsemtblgen.c:639:32: warning: cast from 'const void *' to 'struct json_sem *' drops const qualifier [-Wcast-qual]
    first = (struct json_sem *)a;
                               ^
jsemtblgen.c:640:33: warning: cast from 'const void *' to 'struct json_sem *' drops const qualifier [-Wcast-qual]
    second = (struct json_sem *)b;
                                ^
```

### Solution

Here there was no need for these to be non-const so we changed `first` and
`second` to be const and then changed the casts to be


```c
    first = (const struct json_sem *)a;
    second = (const struct json_sem *)b;
```

and rerun `make clobber all test`.


### See also

With the exception of the one noted that we cannot change all of these were
fixed in commit 8609822e68a369b464a1be924a4b876c78ca563b.


## Issue: warning: enumeration value not explicitly handled in switch
### Status: ignore

### Example


```c
json_sem.c:1138:13: warning: 7 enumeration values not explicitly handled in switch: 'JTYPE_UNSET', 'JTYPE_NUMBER', 'JTYPE_BOOL'... [-Wswitch-enum]
    switch (value->type) {
            ^~~~~~~~~~~
json_sem.c:1138:13: note: add missing switch cases
    switch (value->type) {
            ^
```


### Solution

There is no need to add these to the switch because those values that are not
specified are not supposed to be there and if they are it is an error.
Since only those explicitly checked are valid the `default` will be sufficient
to handle the errors and in a way that even if another was added to the enum we
would not have to worry about it.


### See also

This issue is noted in commit d7555d25565d4b519f865565887837069a25dd13.


## Issue: warning: default label in switch which covers all enumeration values
### Status: ignore

### Example

```c
dyn_array.c:1105:2: warning: default label in switch which covers all enumeration values [-Wcovered-switch-default]
        default:
        ^
```

### Solution

The problem clang is having is that all enum values are already handled so
there's no need for default. But what happens if someone updates the enum to
have a new value which would be an error that the default actually handles? It
would no longer be an error even though it is. Thus we ignore this one too.

The dynamic array code maintains a default switch case in case (pun
intended) the enum values are changed OR in case of a hardware (such
as memory corruption) error.


### See also

Addressed in commit 0c15034ed8697183b09761277e3fd9143b973e17.


## Issue: warning: include location '/usr/local/include' is unsafe for cross-compilation
### Status: ignore

### Example


```sh
make clobber all
[...]
warning: include location '/usr/local/include' is unsafe for cross-compilation [-Wpoison-system-directories]
```

### Solution

This is a warning triggered under macOS and although it appears bogus it's
probably not even though we don't include it explicitly (see next part to see
why this is). The warning can be ignored but it's probably triggered because of
the Makefile variable:


```makefile
.INCLUDE_DIRS = /usr/local/include
```

This variable, which appears to be read-only, can be seen if one does:


```sh
make -p -f /dev/null 2>/dev/null|grep -B 1 INCLUDE
# default
.INCLUDE_DIRS = /usr/local/include
```

Thus although we don't explicitly include the `/usr/local/include` it is at
least in some systems part of the include search path. Under linux it does not
trigger a warning but the value does include it and more:


```makefile
.INCLUDE_DIRS = /usr/include /usr/local/include /usr/include
```

### See also

Commits ae1f962f60344b2509433bb0bbcedc8c9eee9ba6 and
132087c1fb2ca618b726f5aeb3b57983a02550c2.

## Issue: warning: signed shift result sets the sign bit of the shift expression's type  and becomes negative
### Status: ignore

### Example

```c
json_parse.c:1918:35: warning: signed shift result (0x8000000000000000) sets the sign bit of the shift expression's type ('ssize_t' (aka 'long')) and becomes negative [-Wshift-sign-overflow]
        if (item->as_maxint >= (intmax_t)SSIZE_MIN && item->as_maxint <= (intmax_t)SSIZE_MAX) {
                                         ^~~~~~~~~
./util.h:101:32: note: expanded from macro 'SSIZE_MIN'
#define SSIZE_MIN (((ssize_t)1 << (sizeof(ssize_t) * BITS_IN_BYTE - 1)))
                    ~~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

### Solution

The purpose of this macro is to get the signed minimum value and so this is
intended and thus can be ignored.

### See also

Addressed in commit 087e5709022b8b086d17f185fd6bed43bfcd8200..


## Issue: warning: result of comparison is always true
### Status: ignore

### Examples


```c
json_parse.c:1879:64: warning: result of comparison 'intmax_t' (aka 'long') <= 9223372036854775807 is always true [-Wtautological-type-limit-compare]
        if (item->as_maxint >= (intmax_t)INT64_MIN && item->as_maxint <= (intmax_t)INT64_MAX) {
                                                      ~~~~~~~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~~~
json_parse.c:1879:22: warning: result of comparison 'intmax_t' (aka 'long') >= -9223372036854775808 is always true [-Wtautological-type-limit-compare]
        if (item->as_maxint >= (intmax_t)INT64_MIN && item->as_maxint <= (intmax_t)INT64_MAX) {
            ~~~~~~~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~~~
json_parse.c:1897:63: warning: result of comparison 'intmax_t' (aka 'long') <= 9223372036854775807 is always true [-Wtautological-type-limit-compare]
        if (item->as_maxint >= (intmax_t)LONG_MIN && item->as_maxint <= (intmax_t)LONG_MAX) {
                                                     ~~~~~~~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~~
json_parse.c:1897:22: warning: result of comparison 'intmax_t' (aka 'long') >= -9223372036854775808 is always true [-Wtautological-type-limit-compare]
        if (item->as_maxint >= (intmax_t)LONG_MIN && item->as_maxint <= (intmax_t)LONG_MAX) {
            ~~~~~~~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~~

```

### Solution

The purpose of this code is to find which int types the string, when converted to an
int, will fit in. The way this code works is first converting it to an
`intmax_t` (hence `as_maxint`) and then, if no errors, check each signed integer
type range, and if it will fit, assign it as that type. For instance:

```c
        /* case int64_t: range check */
        if (item->as_maxint >= (intmax_t)INT64_MIN && item->as_maxint <= (intmax_t)INT64_MAX) {
            item->int64_sized = true;
            item->as_int64 = (int64_t)item->as_maxint;
        }

```

It just so happens that on this system `intmax_t` is a `long` and so these cases
are always true. Earlier in the file:


```c
        /* case int8_t: range check */
        if (item->as_maxint >= (intmax_t)INT8_MIN && item->as_maxint <= (intmax_t)INT8_MAX) {
            item->int8_sized = true;
            item->as_int8 = (int8_t)item->as_maxint;
        }
```

This doesn't trigger the warning because it is not always true.
When it is true, though, we set the `item->as_int8` to be `item->as_maxint`
cast to an `int8_t`.


### See also

Addressed in commit 3cbb9de013ec99670d0188230997899b18762427.


## Issue: warning: comparing floating point with == or != is unsafe
### Status: fixed

### Examples

```c
dyn_test.c:122:17: warning: comparing floating point with == or != is unsafe [-Wfloat-equal]
        if ((double) i != dyn_array_value(array, double, i)) {
            ~~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dyn_test.c:159:17: warning: comparing floating point with == or != is unsafe [-Wfloat-equal]
        if ((double) i != dyn_array_value(array, double, i)) {
            ~~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dyn_test.c:163:17: warning: comparing floating point with == or != is unsafe [-Wfloat-equal]
        if ((double) i != dyn_array_value(array, double, i+1000000)) {
            ~~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

and

```c
jnum_chk.c:641:16: warning: comparing floating point with == or != is unsafe [-Wfloat-equal]
            if (val_a != val_b) {
                ~~~~~ ^  ~~~~~
```

### Solution

Here we can cast both sides of each to an `intmax_t`.


### See also

Fixed in commit 3b5402bd33e88f79bd20abf61895d2727b79fcac.


## Issue: warning: implicit conversion increases floating-point precision: 'float' to 'double'
### Status: fixed

### Example

```c
json_parse.c:2342:72: warning: implicit conversion increases floating-point precision: 'float' to 'double' [-Wdouble-promotion]
        dbg(DBG_VVVHIGH, "strtof for <%s> returned as %%g: %.22g", str, item->as_float);
        ~~~                                                             ~~~~~~^~~~~~~~
json_parse.c:2343:72: warning: implicit conversion increases floating-point precision: 'float' to 'double' [-Wdouble-promotion]
        dbg(DBG_VVVHIGH, "strtof for <%s> returned as %%e: %.22e", str, item->as_float);
        ~~~                                                             ~~~~~~^~~~~~~~
json_parse.c:2344:72: warning: implicit conversion increases floating-point precision: 'float' to 'double' [-Wdouble-promotion]
        dbg(DBG_VVVHIGH, "strtof for <%s> returned as %%f: %.22f", str, item->as_float);
        ~~~
```

### Solution

As this is for implicit conversion only and since it will become a double we can
cast it to a double to silence the warning.


### See also

Fixed in commit 55950a67be3319c085e0656d45c4391ee79b73c5. See also
207715cf1e4f83d60dd8494d53832a02539c97b9,
207715cf1e4f83d60dd8494d53832a02539c97b9 and
2f68cd3177bef39ddad9dc022e28276165f64927.


## Issue: warning: implicit conversion loses integer precision
### Status: fixed

### Example

```c
utf8_posix_map.c:1601:25: warning: implicit conversion loses integer precision: 'unsigned long' to 'int' [-Wshorten-64-to-32]
        hmap[i].utf8_str_len = strlen(hmap[i].utf8_str);
                             ~ ^~~~~~~~~~~~~~~~~~~~~~~~
utf8_posix_map.c:1602:26: warning: implicit conversion loses integer precision: 'unsigned long' to 'int' [-Wshorten-64-to-32]
        hmap[i].posix_str_len = strlen(hmap[i].posix_str);
                              ~ ^~~~~~~~~~~~~~~~~~~~~~~~~
```

### Solution

These variables in the struct need to be signed as `-1` signifies that it's not
been initialised yet. Now since `strlen()` returns an unsigned int we simply
cast the return value of `strlen()` to an int.


### Example

```c
txzchk.c:1555:22: warning: implicit conversion loses integer precision: 'uintmax_t' (aka 'unsigned long') to 'int' [-Wshorten-64-to-32]
        add_txz_line(linep, line_num);
        ~~~~~~~~~~~~        ^~~~~~~~
```

### Solution

The variable `line_num` is a `uintmax_t` but the function was expecting an
`int`. The struct also had it as an `int` but since it should be unsigned and
since we are being careful to have the maximum size the `int` was changed to
`uintmax_t`.

### Example

```c
verge.c:103:19: warning: implicit conversion loses integer precision: 'size_t' (aka 'unsigned long') to 'int' [-Wshorten-64-to-32]
    ver1_levels = allocate_vers(ver1, &vlevel1);
                ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
verge.c:112:19: warning: implicit conversion loses integer precision: 'size_t' (aka 'unsigned long') to 'int' [-Wshorten-64-to-32]
    ver2_levels = allocate_vers(ver2, &vlevel2);
                ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

### Solution

Although we could change the type of `ver1_levels` and `ver2_levels` this would
introduce the complication of other code so we simply cast the `allocate_vers()`
calls to an int.


### Example

```c
dyn_array.c:878:50: warning: implicit conversion loses integer precision: 'long' to 'int' [-Wshorten-64-to-32]
        data_first_offset = (uint8_t *)(array_to_add_p) - (uint8_t *)(array->data);
                          ~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~
dyn_array.c:879:48: warning: implicit conversion loses integer precision: 'long' to 'int' [-Wshorten-64-to-32]
        data_last_offset = (uint8_t *)(last_add_byte) - (uint8_t *)(array->data);
                         ~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~
```

### Solution

Local variables data_first_offset and data_first_offset in dyn_array.c
were changed to type intmax_t in order to avoid integer precision loses.


### Example

```c
json_parse.c:3265:17: warning: implicit conversion loses integer precision: 'intmax_t' (aka 'long') to 'int' [-Wshorten-64-to-32]
    item->len = yn_array_tell(item->s);
              ~ ^~~~~~~~~~~~~~~~~~~~~~~
./../dyn_array/dyn_array.h:118:67: note: expanded from macro 'dyn_array_tell'
#define dyn_array_tell(array_p) (((struct dyn_array *)(array_p))->count)
                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~
```

### Solution

In the file `json_parse.h` we see that various structs of json types
have an `int len` that instead should be `intmax_t len`, especially
because the dynamic array facility has the potential to return (say
via dyn_array_tell) large lengths (even though this repo is unlikely
to need lengths that would exceed INT_MAX).

### See also

Fixed in commit 277dfe3cd9a2ec9d2684131c791ccf70a248ac2d..


## Issue: warning: implicit conversion changes signedness
### Status: fixed
### Example


```c
txzchk.c:1084:9: warning: implicit conversion changes signedness: 'intmax_t' (aka 'long') to 'unsigned long' [-Wsign-conversion]
    if (*count - tarball.abnormal_files > MAX_FILE_COUNT) {
        ^~~~~~ ~
txzchk.c:1087:59: warning: implicit conversion changes signedness: 'intmax_t' (aka 'long') to 'unsigned long' [-Wsign-conversion]
        warn("txzchk", "%s: too many files: %jd > %jd", txzpath, *count - tarball.abnormal_files, (intmax_t)MAX_FILE_COUNT);
                                                                 ^~~~~~ ~
```

### Solution

Cast the `tarball.abnormal_files` to a `intmax_t` as the ints in `sum_and_count`
have to be signed but we want the count of the abnormal files to be unsigned
otherwise.


### Example

```c
utf8_posix_map.c:1707:46: warning: implicit conversion changes signedness: 'int' to 'unsigned long' [-Wsign-conversion]
            if (strncasecmp(m->utf8_str, name+i, m->utf8_str_len) != 0) {
                ~~~~~~~~~~~                      ~~~^~~~~~~~~~~~

```

### Solution

This was already discussed in another issue. We can cast it to a `uintmax_t` and
we have done so.


### Example

```c
./jparse.y:786:49: warning: implicit conversion changes signedness: 'int' to 'size_t' (aka 'unsigned long') [-Wsign-conversion]
        yyval = parse_json_string(yyget_text(scanner), yyget_leng(scanner));
                ~~~~~~~~~~~~~~~~~                      ^~~~~~~~~~~~~~~~~~~
```

### Solution

As far as this one goes we can cast it to a `size_t` and we have done so.


### Example

```c
foo.c:142:49: warning: implicit conversion changes signedness: 'int' to 'unsigned long' [-Wsign-conversion]
    for (char const *p = oebxergfB[((two*2*2*015+(int)(four/(07&0x07)))%forty)]; *p; ++p) {
                                     ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~ ~
foo.c:275:25: warning: implicit conversion changes signedness: 'int' to 'unsigned int' [-Wsign-conversion]
    no_comment = sleep(1+(((four+two)>0?(four+two):(-two-four))%5));
                 ~~~~~ ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

### Solution

We fixed this with some casts.


### Example

```c
dbg.c:468:36: warning: implicit conversion changes signedness: 'int' to 'unsigned long' [-Wsign-conversion]
    ret2 = vsnprintf(str+ret, size-ret, fmt, ap);
                                  ~^~~
dbg.c:469:30: warning: implicit conversion changes signedness: 'int' to 'unsigned long' [-Wsign-conversion]
    if ((size_t)ret2 >= size-ret) {
                            ~^~~
```
### Solution

We can cast the `ret` to be a `size_t` which is the same type as the `size`
variable.


```c
json_parse.c:300:14: warning: implicit conversion changes signedness: 'long' to 'size_t' (aka 'unsigned long') [-Wsign-conversion]
    mlen = p - ret; /* paranoia */
         ~ ~~^~~~~
```

### Solution

Change the type of `mlen` to `ssize_t`. This does trigger two other warnings,
however:

```c
json_parse.c:257:27: warning: implicit conversion changes signedness: 'long' to 'unsigned long' [-Wsign-conversion]
    ret = malloc(mlen + 1 + 1);
          ~~~~~~ ~~~~~~~~~^~~
json_parse.c:308:12: warning: implicit conversion changes signedness: 'ssize_t' (aka 'long') to 'size_t' (aka 'unsigned long') [-Wsign-conversion]
        *retlen = mlen;
                ~ ^~~~
```

Making `mlem` of type `ssize_t` and adding paranoia checks for < 0 values,
and then casting the non-negative result to `size_t` for `retlen` works.


### Example

```
chk_validate.c:2852:30: warning: implicit conversion changes signedness: 'int' to 'size_t' (aka 'unsigned long') [-Wsign-conversion]
    test = test_rule_2b_size(*value);
           ~~~~~~~~~~~~~~~~~ ^~~~~~
```

### Solution

We can use the recently added function `sem_member_value_size_t` (see commit
e59f15db96dc0893341a985825fbb6028525a278)  and change the type of
`value` to be a pointer to a `size_t` instead of a pointer to an `int`.


### Example

```c
dyn_array.c:145:31: warning: implicit conversion changes signedness: 'unsigned long' to 'intmax_t' (aka 'long') [-Wsign-conversion]
    old_bytes = old_allocated * array->elm_size;
              ~ ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~
dyn_array.c:145:17: warning: implicit conversion changes signedness: 'intmax_t' (aka 'long') to 'unsigned long' [-Wsign-conversion]
    old_bytes = old_allocated * array->elm_size;
                ^~~~~~~~~~~~~ ~
dyn_array.c:147:46: warning: implicit conversion changes signedness: 'unsigned long' to 'intmax_t' (aka 'long') [-Wsign-conversion]
    new_bytes = (new_allocated+array->chunk) * array->elm_size;
              ~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~
dyn_array.c:147:31: warning: implicit conversion changes signedness: 'long' to 'unsigned long' [-Wsign-conversion]
    new_bytes = (new_allocated+array->chunk) * array->elm_size;
                 ~~~~~~~~~~~~~^~~~~~~~~~~~~  ~
dyn_array.c:196:36: warning: implicit conversion changes signedness: 'long' to 'unsigned long' [-Wsign-conversion]
            memset(p, 0, (elms_to_allocate+array->chunk) * array->elm_size);
                          ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~  ~
```

### Solution

While the dynamic array element elm_size is type `size_t`, when
multiplying with such values we cast such values to `intmax_t`.
This can be safely cast within most dyn_array.c code because there
is code ahead of such use to object to negative elm_size values.

### See also

This was fixed in commit
627b587de987153dc5a772a7d7cebda99e08b705 (with the help of commit
e59f15db96dc0893341a985825fbb6028525a278) and
dfce024daba6ea3f32d1ebf54e1ad72a277dfa54.


## Issue: warning: implicit conversion increases floating-point precision: 'double' to 'long double'
### Status: fixed
### Example

```c
json_parse.c:2324:31: warning: implicit conversion increases floating-point precision: 'double' to 'long double' [-Wdouble-promotion]
        item->as_double_int = (item->as_double == floorl(item->as_double));
                               ~~~~~~^~~~~~~~~ ~~
json_parse.c:2324:57: warning: implicit conversion increases floating-point precision: 'double' to 'long double' [-Wdouble-promotion]
        item->as_double_int = (item->as_double == floorl(item->as_double));
                                                  ~~~~~~ ~~~~~~^~~~~~~~~
```

### Solution

We fix this issue by using the `floor()` function instead of `floorl()` because
the `floor()` function returns a `double` which is what we want in this case.

### Example

```c
jnum_gen.c:538:42: warning: implicit conversion increases floating-point precision: 'double' to 'long double' [-Wdouble-promotion]
    fpr_finfo(stream, item->float_sized, (double)item->as_float, item->as_float_int,
    ~~~~~~~~~                            ^~~~~~~~~~~~~~~~~~~~~~
jnum_gen.c:546:49: warning: implicit conversion increases floating-point precision: 'double' to 'long double' [-Wdouble-promotion]
    fpr_finfo(stream, item->double_sized, item->as_double, item->as_double_int,
    ~~~~~~~~~                             ~~~~~~^~~~~~~~~

```

### Solution

As the fpr_finfo() function 3rd value is a `long double`, we cast to the 3rd arg
to `long double` for values that are not otherwise `long double`.


### Example

```c
jnum_gen.c:686:42: warning: implicit conversion increases floating-point precision: 'double' to 'long double' [-Wdouble-promotion]
                       (value <= -100000.0 || value >= 1000000.0) ? "\t" : "\t\t",
                                                    ~~ ^~~~~~~~~
./util.h:155:65: note: expanded from macro 'fprint'
#define fprint(stream, fmt, ...) fpr((stream), __func__, (fmt), __VA_ARGS__)
                                                                ^~~~~~~~~~~
jnum_gen.c:686:20: warning: implicit conversion increases floating-point precision: 'double' to 'long double' [-Wdouble-promotion]
                       (value <= -100000.0 || value >= 1000000.0) ? "\t" : "\t\t",
                              ~~ ^~~~~~~~~
./util.h:155:65: note: expanded from macro 'fprint'
#define fprint(stream, fmt, ...) fpr((stream), __func__, (fmt), __VA_ARGS__)
                                                                ^~~~~~~~~~~

```

### Solution

In this case we can use `L` suffix to make it long double. But is this correct?
It might or might not be. Either way, whether it's correct or not, we can use
the C99 macros `islessequal` and `isgreaterequal` for the comparison.


### Example

```c
jnum_test.c:5474:2: warning: implicit conversion increases floating-point precision: 'double' to 'long double' [-Wdouble-promotion]
        -214748.3647200000000055,       /* JSON floating point value in long double form */
        ^~~~~~~~~~~~~~~~~~~~~~~~
jnum_test.c:5296:2: warning: implicit conversion increases floating-point precision: 'double' to 'long double' [-Wdouble-promotion]
        -2147483647.099999999977,       /* JSON floating point value in long double form */
        ^~~~~~~~~~~~~~~~~~~~~~~~
[...]
```

### Solution

Since this set of warnings was only for the long double values we made a slight
modification to the `jnum_gen` tool so that these will have the `L` suffix.

### See also

Commit 207715cf1e4f83d60dd8494d53832a02539c97b9 and
2f68cd3177bef39ddad9dc022e28276165f64927.


## Issue: warning: macro name is a reserved identifier
### Status: ignore
### Example

```c
jparse.c:63:9: warning: macro name is a reserved identifier [-Wreserved-macro-identifier]
#define __STDC_LIMIT_MACROS 1
        ^
```

### Solution

Since we must not modify `jparse.c` or any code generated from the `jparse.l` or
`jparse.y` files we simply ignore this warning.


### See also

Commit 2eef8867ce411bdcc9422b8cd0ed3657ef3a29a2.


## Issue: warning: disabled expansion of recursive macro
### Status: ignore
### Examples

```c
./jparse.y:874:9: warning: disabled expansion of recursive macro [-Wdisabled-macro-expansion]
        fprint(stderr, " node type %s", json_item_type_name(*node));
               ^
/usr/include/stdio.h:149:16: note: expanded from macro 'stderr'
#define stderr stderr
               ^
```

```c
jsemtblgen.c:318:30: warning: disabled expansion of recursive macro [-Wdisabled-macro-expansion]
            cap_tbl_name[i] = (char)toupper(tbl_name[i]);
                                    ^
/usr/include/ctype.h:221:35: note: expanded from macro 'toupper'
#  define toupper(c)    __tobody (c, toupper, *__ctype_toupper_loc (), (c))
                                     ^
```

### Solution

This is a problem in the system header files and therefore we ignore it.

### See also

Addressed in commit 8311424e8c864ba5fbf72033476b054cf2d5590a.


## Issue: warning: empty expression statement has no effect; remove unnecessary ';'
### Status: ignore
### Example


```c
jparse.c:903:22: warning: empty expression statement has no effect; remove unnecessary ';' to silence this warning [-Wextra-semi-stmt]
                YY_DO_BEFORE_ACTION;
                                   ^
jparse.c:1318:34: warning: empty expression statement has no effect; remove unnecessary ';' to silence this warning [-Wextra-semi-stmt]
                        yyg->yy_n_chars, num_to_read );
                                                      ^
```

### Solution

We cannot modify `jparse.c` but even if we could it probably does not matter so
we ignore this.

### Example

```c
iocccsize.c:122:60: warning: empty expression statement has no effect; remove unnecessary ';' to silence this warning [-Wextra-semi-stmt]
                            iocccsize_errx(4, "cannot parse -v arg: %s", optarg);
                                                                                ^
iocccsize.c:136:90: warning: empty expression statement has no effect; remove unnecessary ';' to silence this warning [-Wextra-semi-stmt]
                        iocccsize_errx(6, "There is NO... Rule 6!  I'm not a number!  I'm a free(void *man)!"); /*ooo*/
                                                                                                              ^
iocccsize.c:157:55: warning: empty expression statement has no effect; remove unnecessary ';' to silence this warning [-Wextra-semi-stmt]
                        iocccsize_errx(6, "fopen(%s) failed", argv[optind]); /*ooo*/
                                                                           ^
```

### Solution

This is something that must be dealt with by Landon but even so it probably does
not matter so whether or not this will be fixed is TBD later.

#### See also

Addressed in commit e2dba0d51b3d65ad753dccdd5c02d5f15ff03de9.


## Issue: warning: unannotated fall-through between switch labels
### Status: fixed
### Example

```c
mkiocccentry.c:211:2: warning: unannotated fall-through between switch labels [-Wimplicit-fallthrough]
        case 'a':               /* -a record_answers */
        ^
mkiocccentry.c:211:2: note: insert '__attribute__((fallthrough));' to silence this warning
        case 'a':               /* -a record_answers */
        ^
        __attribute__((fallthrough));
mkiocccentry.c:211:2: note: insert 'break;' to avoid fall-through
        case 'a':               /* -a record_answers */
        ^
        break;
```

### Solution

This should be ignored because not all compilers have all attributes and we
certainly must fall through to case `'a'` with case `'A'`.

### See also

Addressed in commit 52d95ffd6598959cd415858036d36a9c794bcef2.


## Issue: warning: mixing declarations and code is incompatible with standards before C99
### Status: ignore

### Example


```c
foo.c:99:15: warning: mixing declarations and code is incompatible with standards before C99 [-Wdeclaration-after-statement]
    uintmax_t forty = no_comment;       /* the value is two too much */
              ^
```

### Solution

Although we could assign the value of `no_comment` at declaration we will
provide no comment as to why we do not do that. Since we are using C11 and C11
comes after C99 (by 12 years) and since we'll be moving to C17 sometime later
this year (2023) we do not see this as a problem. Whether it is TBD whether we
will fix this or not we also provide no comment. :-)

### See also

Addressed in commit ca8bc86c7739355850925ada110b7d884e34f754.


# Clang scan-build

Another way to analyse the code is to use clang `scan-build` to compile the
code. To do so one must have the tool compiled and then run:


```sh
make clobber
scan-build make
```

It will compile all the code, looking for problems, and then give you some
information at the end like. For instance running this under macOS:


```sh
scan-build: Analysis run complete.
scan-build: 53 bugs found.
scan-build: Run 'scan-view /var/folders/6n/nb4yym2d1r50sxlz7s0nt3dr0000gn/T/scan-build-2023-01-26-093839-22294-1' to examine bug reports.
```

To not have to worry about finding the path later we can copy the directory to
the current working directory and then run `scan-view` on it. It will open the
report in a browser and you can then peruse the report.

## Issue: Assigned value is garbage or undefined
### Status: ignore (see discussion)
### Example

```
Bug Group 	Bug Type	File	Function/Method	Line	Path Length
Logic error	Assigned value is garbage or undefined	jparse/jparse.tab.c	yyparse	1644	48	View Report	Report Bug	Open File
Logic error	Assigned value is garbage or undefined	jparse/jparse.tab.c	yyparse	1710	48	View Report	Report Bug	Open File
Logic error	Assigned value is garbage or undefined	jparse/jparse.tab.c	yyparse	1677	48	View Report	Report Bug	Open File
Logic error	Assigned value is garbage or undefined	jparse/jparse.tab.c	yyparse	1839	43	View Report	Report Bug	Open File
Logic error	Assigned value is garbage or undefined	jparse/jparse.tab.c	yyparse	2150	48	View Report	Report Bug	Open File
Logic error	Assigned value is garbage or undefined	jparse/jparse.tab.c	yyparse	1553	48	View Report	Report Bug	Open File
Logic error	Assigned value is garbage or undefined	jparse/jparse.tab.c	yyparse	1611	48	View Report	Report Bug	Open File

```

### Solution

The reason we ignore these is because they're in the parser generated code so we
cannot touch it.

